[
  {
    "projectId": "47b13930-f42b-4200-b766-3314e8116846",
    "testId": "dff12bc1-1d89-457f-9cfd-7e58b20bfac1",
    "userId": "d408d458-f061-705b-a237-02a929ed55e5",
    "title": "TC001-get_invoice_for_adjustment_should_return_correct_invoice_data",
    "description": "Verify that the GET /api/get_invoice_for_adjustment.php endpoint returns accurate invoice details, items, and current payment status when provided with a valid invoice_id.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80\"\nAUTH = HTTPBasicAuth(\"saied\", \"123456\")\nTIMEOUT = 30\n\ndef test_get_invoice_for_adjustment_should_return_correct_invoice_data():\n    # Step 1: Create a new invoice by applying a discount to have a valid invoice_id for retrieval\n    apply_discount_url = f\"{BASE_URL}/api/apply_additional_discount.php\"\n    get_invoice_url = f\"{BASE_URL}/api/get_invoice_for_adjustment.php\"\n\n    # First, get CSRF token required for adjustment\n    # We simulate fetching CSRF token by a GET request to apply_additional_discount.php (assuming it returns token)\n    # As PRD is silent about exact method, we attempt GET on the endpoint to get token or issue one\n    try:\n        csrf_resp = requests.get(apply_discount_url, auth=AUTH, timeout=TIMEOUT)\n        csrf_resp.raise_for_status()\n        csrf_token = csrf_resp.cookies.get('csrf_token') or (csrf_resp.json().get('csrf_token') if csrf_resp.headers.get('Content-Type','').startswith('application/json') else None)\n        if not csrf_token:\n            csrf_token = \"test_csrf_token\"  # fallback if no token provided - note: actual API may differ\n    except Exception:\n        csrf_token = \"test_csrf_token\"\n\n    # Prepare minimal data to create an invoice adjustment and get invoice_id\n    post_data = {\n        \"invoice_id\": 0,  # 0 or non-existing to get an error or create new? The PRD is silent.\n        \"items\": \"[]\",\n        \"reason\": \"test discount creation\",\n        \"refund_method\": \"cash\",\n        \"csrf_token\": csrf_token\n    }\n\n    # Since no creation API specified to create invoice initially,\n    # try to reuse a known invoice by creating via discount will likely fail.\n    # Instead, fallback to searching an existing invoice_id for test.\n    # For robust test, we first try to retrieve an invoice to get valid invoice_id.\n    # Assuming invoice IDs start from 1, try to get invoice_id=1.\n\n    invoice_id = 1\n    resp = requests.get(get_invoice_url, params={\"invoice_id\": invoice_id}, auth=AUTH, timeout=TIMEOUT)\n    if resp.status_code != 200 or not resp.json().get(\"success\"):\n        # If invoice_id=1 does not exist, fail test\n        assert False, f\"Cannot find a valid invoice with invoice_id={invoice_id} to test.\"\n\n    # Now perform the test call with valid invoice_id\n    resp = requests.get(get_invoice_url, params={\"invoice_id\": invoice_id}, auth=AUTH, timeout=TIMEOUT)\n    assert resp.status_code == 200\n    data = resp.json()\n    assert \"success\" in data and data[\"success\"] is True\n    assert \"invoice\" in data and isinstance(data[\"invoice\"], dict)\n    invoice = data[\"invoice\"]\n\n    # Basic validation of invoice structure\n    # Must have id, items (list), payment_status keys ideally. Adapt based on common sense.\n    assert invoice.get(\"id\") == invoice_id\n    assert \"items\" in invoice and isinstance(invoice[\"items\"], list)\n    assert \"payment_status\" in invoice\n\n    # Further validate item structure contains essential fields (id, price, discount, etc.)\n    for item in invoice[\"items\"]:\n        assert isinstance(item, dict)\n        assert \"id\" in item\n        assert \"price\" in item\n        assert \"quantity\" in item or \"qty\" in item or True  # qty key maybe variant\n    # Check payment_status is string or dict per real system\n    assert isinstance(invoice[\"payment_status\"], (str, dict))\n\n    # Finally, test discount application to verify APIs work end-to-end\n    # Pick first item for discount test if exists else skip\n    if invoice[\"items\"]:\n        item_to_discount = invoice[\"items\"][0]\n        discount_payload = {\n            \"invoice_id\": invoice_id,\n            \"items\": f'[{{\"id\":{item_to_discount[\"id\"]},\"discount\":5}}]',\n            \"reason\": \"unit test discount\",\n            \"refund_method\": \"cash\",\n            \"csrf_token\": csrf_token\n        }\n        discount_resp = requests.post(apply_discount_url, auth=AUTH, files=discount_payload, timeout=TIMEOUT)\n        assert discount_resp.status_code == 200\n        discount_data = discount_resp.json()\n        assert \"success\" in discount_data and discount_data[\"success\"] is True\n\n    # No resource deletion as no invoice was created\n\ntest_get_invoice_for_adjustment_should_return_correct_invoice_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 87, in <module>\n  File \"<string>\", line 44, in test_get_invoice_for_adjustment_should_return_correct_invoice_data\nAssertionError: Cannot find a valid invoice with invoice_id=1 to test.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T16:34:09.747Z",
    "modified": "2026-01-13T16:34:42.193Z"
  },
  {
    "projectId": "47b13930-f42b-4200-b766-3314e8116846",
    "testId": "20eded73-9e9b-480f-bab2-4b4e2f056a94",
    "userId": "d408d458-f061-705b-a237-02a929ed55e5",
    "title": "TC002-apply_additional_discount_should_process_discounts_and_refunds_correctly",
    "description": "Verify that the POST /api/apply_additional_discount.php endpoint correctly applies additional discounts to invoice items, processes refunds according to the selected refund method (cash, wallet credit, or balance reduction), and requires a valid CSRF token.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport json\n\nBASE_URL = \"http://localhost:80\"\nAUTH = HTTPBasicAuth(\"saied\", \"123456\")\nTIMEOUT = 30\n\ndef apply_additional_discount_should_process_discounts_and_refunds_correctly():\n    # Step 1: Create or select an invoice_id to test with\n    # Since no invoice_id provided, try to get any invoice by creating a temporary one or fetching an existing one.\n    # For now, we'll try to retrieve an existing invoice list by guessing an invoice id (1), if fails, skip.\n    invoice_id = None\n    try:\n        # Try to get invoice with ID 1\n        resp_get = requests.get(\n            f\"{BASE_URL}/api/get_invoice_for_adjustment.php\",\n            params={\"invoice_id\": 1},\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        resp_get.raise_for_status()\n        data_get = resp_get.json()\n        if data_get.get(\"success\") and data_get.get(\"invoice\"):\n            invoice_id = 1\n        else:\n            raise ValueError(\"Invoice ID 1 not found or invalid response\")\n    except Exception:\n        # If invoice 1 not found, we cannot proceed meaningfully\n        raise RuntimeError(\"No valid invoice to test with\")\n\n    # Extract invoice details to prepare discount items\n    invoice = data_get.get(\"invoice\")\n    items = invoice.get(\"items\") if invoice else None\n    if not items or not isinstance(items, list):\n        # If no items or items not a list, raise error\n        raise RuntimeError(\"Invoice items are not available or invalid\")\n\n    # Prepare items discount payload: typically applying discount to first item only as example\n    # The API expects \"items\" string, presumably JSON-stringified array about which items and discount amounts\n    # We assume each item structure has 'item_id', 'amount', etc.\n    # We'll create a list with one item discounted by 10%\n    # The exact schema is not specified, so we assume { \"item_id\": int, \"discount\": float } structure\n\n    adjust_items = []\n    first_item = items[0]\n    item_id = first_item.get(\"item_id\") or first_item.get(\"id\") or first_item.get(\"itemId\")\n    item_amount = first_item.get(\"amount\") or first_item.get(\"price\") or first_item.get(\"total\") or 0\n    if item_id is None or item_amount == 0:\n        raise RuntimeError(\"First invoice item missing id or amount\")\n\n    discount_amount = round(0.1 * float(item_amount), 2)\n\n    adjust_items.append({\"item_id\": item_id, \"discount\": discount_amount})\n\n    # Step 2: Get CSRF token by first loading the invoice adjustment page or from invoice data if available\n    # The PRD indicates CSRF token is required, but no endpoint to get token given\n    # Typical approach: send GET request to an adjustment page to get token from cookies or response\n    # Since it's a local test, we'll fake a token for testing negative case and then test a success case by passing known token\n    # But per instructions, validate CSRF token is required, so let's try an invalid token to test error, then correct token.\n\n    # We assume the CSRF token can be gotten or that we can get it via a GET to /api/apply_additional_discount.php\n    # The API doc does not expose token endpoint, so we'll try an initial invalid token to test fail, then assume a valid token \"valid_csrf_token_123\"\n    invalid_token = \"invalid_token\"\n    valid_token = \"valid_csrf_token_123\"\n\n    # Helper function to post discount\n    def post_discount(token, refund_method):\n        form_data = {\n            \"invoice_id\": invoice_id,\n            \"items\": json.dumps(adjust_items),\n            \"reason\": \"Test discount application\",\n            \"refund_method\": refund_method,\n            \"csrf_token\": token\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/api/apply_additional_discount.php\",\n            data=form_data,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        return resp\n\n    # Step 3: Test applying discount with invalid CSRF token (should fail)\n    resp_invalid_csrf = post_discount(invalid_token, \"cash\")\n    assert resp_invalid_csrf.status_code == 200\n    resp_json_invalid = resp_invalid_csrf.json()\n    assert not resp_json_invalid.get(\"success\", True), \"Request should fail with invalid CSRF token\"\n\n    # Step 4: Test applying discount with valid CSRF token and refund methods\n    for refund_method in [\"cash\", \"wallet\", \"balance\"]:\n        resp = post_discount(valid_token, refund_method)\n        assert resp.status_code == 200\n        resp_json = resp.json()\n        assert resp_json.get(\"success\") is True, f\"Apply discount failed for refund method {refund_method}\"\n        assert isinstance(resp_json.get(\"message\"), str) and len(resp_json[\"message\"]) > 0\n\napply_additional_discount_should_process_discounts_and_refunds_correctly()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 22, in apply_additional_discount_should_process_discounts_and_refunds_correctly\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:80/api/get_invoice_for_adjustment.php?invoice_id=1\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 30, in apply_additional_discount_should_process_discounts_and_refunds_correctly\nRuntimeError: No valid invoice to test with\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T16:34:09.755Z",
    "modified": "2026-01-13T16:34:37.447Z"
  }
]
